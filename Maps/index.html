<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Peaks I Have Bagged</title>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css"
    />
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      }
      #map {
        height: 100%;
        width: 100%;
      }
      .custom-map-title {
        position: fixed;
        top: 12px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        background-color: rgba(255, 255, 255, 0.9);
        padding: 8px 16px;
        border-radius: 8px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }
      .custom-map-title h2 {
        margin: 0;
        font-size: 1.1rem;
        font-weight: 600;
        color: #222;
      }

      .visible-counter {
        position: fixed;
        right: 16px;
        bottom: 128px; /* sits above the floating buttons */
        z-index: 1100;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(0, 0, 0, 0.12);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.22);
        padding: 8px 12px;
        border-radius: 999px;
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size: 0.9rem;
        color: #111;
        user-select: none;
        line-height: 1;
        pointer-events: none; /* don't block map interactions */
      }

      @media (max-width: 480px) {
        .visible-counter {
          right: 12px;
          bottom: 184px;
        }
      }
      .leaflet-popup-content {
        font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      }
      .popup-actions {
        margin-top: 8px;
        display: flex;
        gap: 6px;
        align-items: center;
      }

      /* Icon-only copy button inside popup */
      .popup-icon-button {
        appearance: none;
        border: 1px solid rgba(0, 0, 0, 0.18);
        background: rgba(255, 255, 255, 0.95);
        color: #111;
        border-radius: 8px;
        width: 28px;
        height: 28px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      .popup-icon-button:hover {
        background: #fff;
        border-color: rgba(0, 0, 0, 0.28);
      }
      .popup-icon-button:active {
        transform: translateY(0.5px);
      }
      .popup-icon-button svg {
        width: 16px;
        height: 16px;
        display: block;
      }
      .popup-icon-button:focus-visible {
        outline: 3px solid rgba(30, 91, 147, 0.45);
        outline-offset: 2px;
      }
      .popup-icon-button:disabled {
        opacity: 0.6;
        cursor: default;
      }

      /* Optional tiny feedback text */
      .popup-copied {
        font-size: 0.75rem;
        color: #1e5b93;
        margin-left: 4px;
      }

      /* Floating buttons */
      .floating-home,
      .floating-alltrails {
        position: fixed;
        right: 16px;
        z-index: 1100;
        width: 48px;
        height: 48px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(0, 0, 0, 0.12);
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.22);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        color: #111;
        -webkit-tap-highlight-color: transparent;
      }

      .floating-home {
        bottom: 16px;
      }

      .floating-alltrails {
        bottom: 72px;
      }

      .floating-home:hover,
      .floating-alltrails:hover {
        transform: translateY(-1px);
        box-shadow: 0 8px 22px rgba(0, 0, 0, 0.24);
      }
      .floating-home:active,
      .floating-alltrails:active {
        transform: translateY(0px);
      }
      .floating-home svg,
      .floating-alltrails svg {
        width: 22px;
        height: 22px;
        display: block;
      }
      .floating-home:focus-visible,
      .floating-alltrails:focus-visible {
        outline: 3px solid rgba(30, 91, 147, 0.5);
        outline-offset: 3px;
      }

      /* Avoid overlapping Leaflet's bottom-right controls */
      @media (max-width: 480px) {
        .floating-home {
          right: 12px;
          bottom: 72px;
        }
        .floating-alltrails {
          right: 12px;
          bottom: 128px;
        }
      }
    </style>
  </head>
  <body>
    <div class="custom-map-title">
      <h2>Peaks I Have Bagged</h2>
    </div>
    <div class="visible-counter" id="visibleCounter">0/0 visible</div>
    <div id="map"></div>

    <a
      class="floating-alltrails"
      href="https://www.alltrails.com/members/yann-saint-laurent"
      target="_blank"
      rel="noopener noreferrer"
      aria-label="Open AllTrails profile"
      title="AllTrails profile"
    >
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <path
          fill="currentColor"
          d="M3 19h18v2H3v-2Zm1-2 5.2-9.2c.2-.4.6-.6 1-.6s.8.2 1 .6L13 11l1.8-3.2c.2-.4.6-.6 1-.6s.8.2 1 .6L20 17H4Zm2.3 0h11.5L16.6 9.9 15 12.8c-.2.4-.6.6-1 .6s-.8-.2-1-.6l-2.8-4.9L6.3 17Z"
        />
      </svg>
    </a>

    <a class="floating-home" href="../index.html" aria-label="Back to home" title="Back to home">
      <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
        <path
          fill="currentColor"
          d="M12 3.2 2.6 11h1.9v9.3c0 .9.7 1.7 1.7 1.7h4.7v-6.6h2.2V22h4.7c.9 0 1.7-.7 1.7-1.7V11h1.9L12 3.2Zm6 17.1c0 .1-.1.2-.2.2h-3.2v-6.6H9.4v6.6H6.2c-.1 0-.2-.1-.2-.2v-10l6-5 6 5v10Z"
        />
      </svg>
    </a>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
    <script>
      // Persist map view + overlay toggles (per-user, per-browser)
      const STORAGE_KEY = "yann-maps-state-v1";

      function loadMapState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) return null;
          return JSON.parse(raw);
        } catch {
          return null;
        }
      }

      function saveMapState(nextState) {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(nextState));
        } catch {
          // ignore (privacy mode / quota)
        }
      }

      const savedState = loadMapState();
      const defaultView = { center: [50.05917, -122.95694], zoom: 11 };
      const hasSavedView =
        Array.isArray(savedState?.center) &&
        savedState.center.length === 2 &&
        typeof savedState.center[0] === "number" &&
        typeof savedState.center[1] === "number" &&
        typeof savedState?.zoom === "number";

      const initialView = hasSavedView
        ? { center: savedState.center, zoom: savedState.zoom }
        : defaultView;

      const map = L.map("map", { zoomControl: true }).setView(
        initialView.center,
        initialView.zoom
      );

      L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution:
          "&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors",
      }).addTo(map);

      // Routes (GeoJSON overlays)
      const overlays = {};
      const layerControl = L.control
        .layers(null, overlays, { collapsed: true })
        .addTo(map);

      // Restore overlays (on/off) from prior session, if available
      const savedEnabledOverlays = Array.isArray(savedState?.enabledOverlays)
        ? savedState.enabledOverlays
        : null;

      function getEnabledOverlayLabels() {
        return Object.entries(overlays)
          .filter(([, layer]) => map.hasLayer(layer))
          .map(([label]) => label);
      }

      function persistCurrentState() {
        const center = map.getCenter();

        // Leaflet fires move/zoom events during initial load.
        // If we persist before overlays are registered, we can accidentally wipe
        // the saved enabledOverlays list. So keep the previous list until at
        // least one overlay is known.
        const enabledOverlays = Object.keys(overlays).length
          ? getEnabledOverlayLabels()
          : savedEnabledOverlays || [];

        saveMapState({
          center: [center.lat, center.lng],
          zoom: map.getZoom(),
          enabledOverlays,
        });
      }

      map.on("moveend", persistCurrentState);
      map.on("zoomend", persistCurrentState);
      map.on("overlayadd", persistCurrentState);
      map.on("overlayremove", persistCurrentState);

      // Keep all routes the same color for visual consistency
      const ROUTE_COLOR = "#d23f31";

      // Peaks that have an associated route overlay: style their marker to match
      // the route color so it's visually obvious.
      const ROUTE_PEAK_NAMES = new Set([
        // Peaks that correspond to one of the route overlays
        "Mount Fromme",
        "Elk Mountain",
        "Flora Peak",
        "Eastern Lookout",
        "Hope Peak (Middle Sister)",
        "East End of Rundle",
        "Mount Harvey",
        "Three Brothers Mountain",
        "Cheam Peak",
        // Russet → Overlord route region
        "Whirlwind Peak",
        "Overlord Mountain",
      ]);

      // Same marker style as Leaflet default, but with a custom color.
      function makeColoredMarkerIcon(color) {
        const svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="25" height="41" viewBox="0 0 25 41">
  <path d="M12.5 0C5.6 0 0 5.6 0 12.5 0 22.3 12.5 41 12.5 41S25 22.3 25 12.5C25 5.6 19.4 0 12.5 0z" fill="${color}"/>
  <path d="M12.5 1.8C6.6 1.8 1.8 6.6 1.8 12.5c0 7.9 10.7 24.4 10.7 24.4S23.2 20.4 23.2 12.5C23.2 6.6 18.4 1.8 12.5 1.8z" fill="rgba(0,0,0,0.25)"/>
  <circle cx="12.5" cy="12.5" r="5.5" fill="#ffffff" fill-opacity="0.9"/>
</svg>`;

        const url =
          "data:image/svg+xml;charset=UTF-8," + encodeURIComponent(svg);

        return L.icon({
          iconUrl: url,
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowUrl:
            "https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/images/marker-shadow.png",
          shadowSize: [41, 41],
          shadowAnchor: [12, 41],
        });
      }

      const routePeakIcon = makeColoredMarkerIcon(ROUTE_COLOR);

      function addRoute({ url, label, gpxUrl }) {
        fetch(url)
          .then((r) => r.json())
          .then((geojson) => {
            const routeLayer = L.geoJSON(geojson, {
              style: {
                color: ROUTE_COLOR,
                weight: 4,
                opacity: 0.9,
              },
              onEachFeature: (feature, layer) => {
                const title = feature?.properties?.name || label;
                const source = feature?.properties?.source;
                const sourceLine = source
                  ? `<div style=\"opacity:0.75; font-size:0.8rem; margin-top:6px;\">${source}</div>`
                  : "";
                const downloadLine = gpxUrl
                  ? `<div style="margin-top:8px;"><a href="${gpxUrl}" download>Download GPX</a></div>`
                  : "";
                const html = `<div><b>${title}</b>${sourceLine}${downloadLine}</div>`;
                layer.bindPopup(html);
              },
            });

            overlays[label] = routeLayer;
            layerControl.addOverlay(routeLayer, label);

            const shouldShowByDefault = savedEnabledOverlays
              ? savedEnabledOverlays.includes(label)
              : true;
            if (shouldShowByDefault) {
              routeLayer.addTo(map);
            }

            persistCurrentState();

            // (route stats removed)
          })
          .catch((err) => {
            console.error(`Failed to load route ${label}`, err);
          });
      }

      addRoute({
        url: "routes/fromme.geojson",
        label: "Fromme route",
        gpxUrl: "routes-gpx/fromme.gpx",
      });

      addRoute({
        url: "routes/elk.geojson",
        label: "Elk Mountain route",
        gpxUrl: "routes-gpx/elk.gpx",
      });

      addRoute({
        url: "routes/flora.geojson",
        label: "Flora Peak route",
        gpxUrl: "routes-gpx/flora.gpx",
      });

      addRoute({
        url: "routes/sumas.geojson",
        label: "Sumas Super Grind route",
        gpxUrl: "routes-gpx/sumas.gpx",
      });

      addRoute({
        url: "routes/middle-sister.geojson",
        label: "Middle Sister Trail route",
        gpxUrl: "routes-gpx/middle-sister.gpx",
      });

      addRoute({
        url: "routes/eeor.geojson",
        label: "East End of Rundle (EEOR) route",
        gpxUrl: "routes-gpx/eeor.gpx",
      });

      addRoute({
        url: "routes/russet-to-overlord.geojson",
        label: "Russet Lake → Overlord (via Whirlwind) route",
        gpxUrl: "routes-gpx/russet-to-overlord.gpx",
      });

      addRoute({
        url: "routes/mount-harvey.geojson",
        label: "Mount Harvey route",
        gpxUrl: "routes-gpx/mount-harvey.gpx",
      });

      addRoute({
        url: "routes/three-brothers.geojson",
        label: "Three Stooges route",
        gpxUrl: "routes-gpx/three-brothers.gpx",
      });

      addRoute({
        url: "routes/cheam.geojson",
        label: "Cheam Peak route",
        gpxUrl: "routes-gpx/cheam.gpx",
      });

      const visibleCounterEl = document.getElementById("visibleCounter");
      let allMarkers = [];

      function updateVisibleCounter() {
        if (!visibleCounterEl) {
          return;
        }
        const total = allMarkers.length;
        if (!total) {
          visibleCounterEl.textContent = "0/0 visible";
          return;
        }
        const bounds = map.getBounds();
        let visible = 0;
        for (const marker of allMarkers) {
          const ll = marker.getLatLng();
          if (bounds.contains(ll)) {
            visible += 1;
          }
        }
        visibleCounterEl.textContent = `${visible}/${total} visible`;
      }

      fetch("peaks.json")
        .then((response) => response.json())
        .then((data) => {
          const peaks = data.Peaks || data.peaks || data;
          if (!Array.isArray(peaks) || peaks.length === 0) {
            return;
          }

          const bounds = [];
          const markers = [];
          peaks.forEach((peak) => {
            if (typeof peak.lat !== "number" || typeof peak.lon !== "number") {
              return;
            }
            const isRoutePeak = ROUTE_PEAK_NAMES.has(peak.name);

            const marker = isRoutePeak
              ? L.marker([peak.lat, peak.lon], { icon: routePeakIcon }).addTo(map)
              : L.marker([peak.lat, peak.lon]).addTo(map);
            const details = peak.details ? `<br>${peak.details}` : "";
            const popupContent = `
              <div>
                <b>${peak.name}</b>${details}
                <div class="popup-actions">
                  <button class="popup-icon-button copy-peak" data-peak-name="${peak.name}" aria-label="Copy peak name" title="Copy peak name">
                    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                      <path
                        fill="currentColor"
                        d="M16 1H6c-1.1 0-2 .9-2 2v12h2V3h10V1Zm3 4H10c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2Zm0 16H10V7h9v14Z"
                      />
                    </svg>
                  </button>
                  <span class="popup-copied" style="display:none;">Copied</span>
                </div>
              </div>
            `;
            marker.bindPopup(popupContent);
            bounds.push([peak.lat, peak.lon]);
            markers.push(marker);
          });

          allMarkers = markers;

          // Only auto-zoom to show all pins if we *don't* already have a saved view.
          // Otherwise this overrides the persisted zoom/center on every refresh.
          if (!hasSavedView) {
            if (bounds.length === 1) {
              map.setView(bounds[0], 12);
            } else if (bounds.length > 1) {
              map.fitBounds(bounds, { padding: [30, 30] });
            }
          }

          // initial counter render after the map has settled
          map.whenReady(() => {
            updateVisibleCounter();
          });
        })
        .catch((error) => {
          console.error("Failed to load peaks.json", error);
        });

      map.on("moveend", updateVisibleCounter);
      map.on("zoomend", updateVisibleCounter);

      map.on("popupopen", (event) => {
        const popupElement = event.popup.getElement();
        if (!popupElement) {
          return;
        }

        const copyButton = popupElement.querySelector(".copy-peak");
        const copiedLabel = popupElement.querySelector(".popup-copied");
        if (!copyButton) {
          return;
        }

        copyButton.addEventListener("click", async () => {
          const peakName = copyButton.getAttribute("data-peak-name") || "";
          if (!peakName) {
            return;
          }
          try {
            await navigator.clipboard.writeText(peakName);
            copyButton.disabled = true;
            if (copiedLabel) {
              copiedLabel.style.display = "inline";
            }
            window.setTimeout(() => {
              copyButton.disabled = false;
              if (copiedLabel) {
                copiedLabel.style.display = "none";
              }
            }, 900);
          } catch (error) {
            console.error("Failed to copy peak name", error);
          }
        });
      });
    </script>
  </body>
</html>
